trigger:
  - 'feature-ms-eduardoAvello-mensaje'

pool:
  vmImage: ubuntu-latest
  #name: EduPc
steps:
  - task: Gradle@3
    inputs:
      gradleWrapperFile: 'gradlew'
      tasks: 'clean build jacocoTestReport'
      publishJUnitResults: true
      testResultsFiles: '**/TEST-*.xml'
      testRunTitle: 'Build and Generate JaCoCo report'
      javaHomeOption: 'JDKVersion'
      sonarQubeRunAnalysis: false
      spotBugsAnalysis: true
    displayName: 'Build and generate JaCoCo report'

  - task: PowerShell@2
    inputs:
      targetType: 'inline'
      script: |
        $htmlReportPath = "${buildDir}/jacocoHtml/test/html/index.html"
        Write-Host "HTML report path: $htmlReportPath"  # Add this line to log the path
        $coverageDataXml = Get-Content -Path "$(System.DefaultWorkingDirectory)/build/jacocoHtml/test/jacocoTestReport.xml" -Raw
        Write-Host "XML report : $coverageDataXml"
        $coverageData = Get-Content -Path "$(System.DefaultWorkingDirectory)/build/jacocoHtml/test/html/index.html" -Raw
        # Realiza el análisis del archivo HTML para obtener los datos de cobertura necesarios
        # Puedes utilizar expresiones regulares o técnicas de manipulación de cadenas para extraer los datos específicos que necesitas
        $pattern = 'class="ctr2">(\d+)%<\/td>'
        $coverageLine = $coverageData | Select-String -Pattern $pattern | ForEach-Object { $_.Matches.Groups[1].Value }
        $coverage = [int]$coverageLine
      
        if ($coverage -lt 0) {
          Write-Host "Code coverage is below 85% ($coverage%). Failing the pipeline."
          exit 1
        } else {
          Write-Host "Code coverage is above 85% ($coverage%)."
        }
    displayName: 'Check code coverage JaCoCoReport'

  - task: PublishCodeCoverageResults@1
    inputs:
      codeCoverageTool: 'JaCoCo'
      summaryFileLocation: '$(System.DefaultWorkingDirectory)/build/jacocoHtml/test/jacocoTestReport.xml'
      reportDirectory: '$(System.DefaultWorkingDirectory)/build/jacocoHtml/test/html/'

  - task: SonarCloudPrepare@1
    inputs:
      SonarCloud: 'SonarCloud'
      organization: 'alushiro'
      projectKey: 'alushiro_microservicio-spring-v4'
      projectName: 'microservicio-spring-v4'
      extraProperties: |
        sonar.pullrequest.provider=none
        sonar.scm.disabled=true
        sonar.coverage.jacoco.xmlReportPaths=$(System.DefaultWorkingDirectory)/build/jacocoHtml/test/jacocoTestReport.xml
    displayName: 'SonarCloud Prepare'
  - task: Gradle@3
    inputs:
      gradleWrapperFile: 'gradlew'
      tasks: 'clean build jacocoTestReport'
      publishJUnitResults: true
      testResultsFiles: '**/TEST-*.xml'
      testRunTitle: 'Build and Generate JaCoCo report'
      javaHomeOption: 'JDKVersion'
      sonarQubeRunAnalysis: false
      spotBugsAnalysis: true
    displayName: 'Build and generate JaCoCo report'

  - task: PowerShell@2
    inputs:
      targetType: 'inline'
      script: |
        $htmlReportPath = "${buildDir}/jacocoHtml/test/html/index.html"
        Write-Host "HTML report path: $htmlReportPath"  # Add this line to log the path
        $coverageDataXml = Get-Content -Path "$(System.DefaultWorkingDirectory)/build/jacocoHtml/test/jacocoTestReport.xml" -Raw
        Write-Host "XML report : $coverageDataXml"
        $coverageData = Get-Content -Path "$(System.DefaultWorkingDirectory)/build/jacocoHtml/test/html/index.html" -Raw
        # Realiza el análisis del archivo HTML para obtener los datos de cobertura necesarios
        # Puedes utilizar expresiones regulares o técnicas de manipulación de cadenas para extraer los datos específicos que necesitas
        $pattern = 'class="ctr2">(\d+)%<\/td>'
        $coverageLine = $coverageData | Select-String -Pattern $pattern | ForEach-Object { $_.Matches.Groups[1].Value }
        $coverage = [int]$coverageLine
      
        if ($coverage -lt 0) {
          Write-Host "Code coverage is below 85% ($coverage%). Failing the pipeline."
          exit 1
        } else {
          Write-Host "Code coverage is above 85% ($coverage%)."
        }
    displayName: 'Check code coverage JaCoCoReport'

  - task: PublishCodeCoverageResults@1
    inputs:
      codeCoverageTool: 'JaCoCo'
      summaryFileLocation: '$(System.DefaultWorkingDirectory)/build/jacocoHtml/test/jacocoTestReport.xml'
      reportDirectory: '$(System.DefaultWorkingDirectory)/build/jacocoHtml/test/html/'

  - task: SonarCloudPrepare@1
    inputs:
      SonarCloud: 'SonarCloud'
      organization: 'alushiro'
      projectKey: 'alushiro_microservicio-spring-v4'
      projectName: 'microservicio-spring-v4'
      extraProperties: |
        sonar.pullrequest.provider=none
        sonar.scm.disabled=true
        sonar.coverage.jacoco.xmlReportPaths=$(System.DefaultWorkingDirectory)/build/jacocoHtml/test/jacocoTestReport.xml
    displayName: 'SonarCloud Prepare'
    
  - task: Gradle@3
    inputs:
      gradleWrapperFile: 'gradlew'
      tasks: 'sonarqube'
      publishJUnitResults: true
      javaHomeOption: 'JDKVersion'
      sonarQubeRunAnalysis: true
      sqGradlePluginVersionChoice: 'specify'
      sonarQubeGradlePluginVersion: '3.5.0.2730'
      spotBugsAnalysis: false

  - task: Docker@2
    inputs:
      containerRegistry: 'Docker'
      command: 'login'
    
  - task: Docker@2
    inputs:
      containerRegistry: 'Docker'
      repository: 'alushiro/microservicio-spring-v4'
      command: 'build'
      Dockerfile: '**/Dockerfile'
      tags: |
        $(Build.BuildId)
        latest

  - task: Docker@2
    inputs:
      containerRegistry: 'Docker'
      repository: 'alushiro/microservicio-spring-v4'
      command: 'push'

 # - script: |   
 #     docker run --rm -p 8085:8085 alushiro/microservicio-spring-v4
 #     response=$(curl -s http://localhost:8085/greeting)
 #     echo "Response from the service: $response" 
 #   displayName: 'Call Dockerized Service (microservicio)'

  - script: |
      docker run --rm -p 8085:8085 alushiro/microservicio-spring-v4
#      echo "Waiting for the service to start..."
#      timeout /t 30 /nobreak > NUL
#      echo "Calling the Dockerized service"
#      response=$(curl -s http://127.0.0.1:8085/greeting)
#      echo "Response from the service: $response" 
    displayName: 'Deploy Dockerized Service (microservicio)'


#  - task: Docker@2
#    displayName: 'Build and publish Docker image with Jmeter'
#    inputs:
#      containerRegistry: 'Docker'  
#      repository: 'alushiro/jmeter'  
#      command: 'buildAndPush'
#      Dockerfile: '**/Dockerfile'
    
#  - script: |    
#      docker run --rm -v $(Build.SourcesDirectory):/jmeter alushiro/jmeter
#    displayName: 'Call Dockerized Service (Jmeter)'
  - task: PowerShell@2
    inputs:
      targetType: 'inline'
      script: |
        # Ruta al archivo JMX de JMeter

        $jmeterFolder = "C:\Users\eduar\Downloads\apache-jmeter-5.5\apache-jmeter-5.5\bin\"
        $jmeterScriptPath = "${jmeterFolder}DevopsTest.jmx"

        # Ruta de salida para los resultados de JMeter
        $jmeterResultsPath = "$(System.DefaultWorkingDirectory)/jmeter_results.jtl"

        # Comando para ejecutar JMeter
        $jmeterCommand = "jmeter -n -t `"$jmeterScriptPath`" -l `"$jmeterResultsPath`""

        # Ejecutar el comando de JMeter
        Write-Host "Running JMeter..."
        Invoke-Expression $jmeterCommand

        # Verificar los resultados de JMeter
        if (!(Test-Path $jmeterResultsPath)) {
          Write-Host "JMeter execution failed. No results file found."
          exit 1
        }

        # Imprimir la ruta del archivo de resultados
        Write-Host "JMeter results file path: $jmeterResultsPath"
    displayName: 'Run JMeter'
